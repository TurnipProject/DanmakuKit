//
//  DanmakuGifCell.swift
//  DanmakuKit
//
//  Created by Q YiZhong on 2021/8/30.
//

import UIKit

fileprivate func dispatchSyncMain(_ closure: (() -> Void)) {
    if Thread.isMainThread {
        closure()
    } else {
        DispatchQueue.main.sync(execute: closure)
    }
}

fileprivate let DANMAKU_GIF_ANIMATION_KEY = "DANMAKU_GIF_ANIMATION_KEY"


/// You can use or inherit this cell to shoot a danmaku with a GIF animation.
/// You need to implement the DanmakuGifCellModel protocol for your data source.
/// And specify that the cellClass generated by the data source is DanmakuGifCell or a subclass derived from it.
/// This is a subclass that only shows GIF capabilities.
/// If you want to implement other specific features, you can refer to the implementation of this class.
open class DanmakuGifCell: DanmakuCell {
    
    /// The animation length of each frame, default is 0.1.
    public var minFrameDuration: Float = 0.1
    
    private var gifModel: DanmakuGifCellModel? {
        return model as? DanmakuGifCellModel
    }
    
    public required init(frame: CGRect) {
        super.init(frame: frame)
        displayAsync = false
    }
    
    public required init?(coder: NSCoder) {
        super.init(coder: coder)
    }
    
    open override func displaying(_ context: CGContext, _ size: CGSize, _ isCancelled: Bool) {
        //在主线程，不需要考虑多线程问题
        dispatchSyncMain {
            guard self.layer.animation(forKey: DANMAKU_GIF_ANIMATION_KEY) == nil else { return }
            guard let animation = createGIFAnimation() else {
                debugPrint("Could not create gif animetion.")
                return
            }
            self.layer.add(animation, forKey: DANMAKU_GIF_ANIMATION_KEY)
        }
    }
    
    private func createGIFAnimation() -> CAKeyframeAnimation? {
        guard let data = gifModel?.resource else { return nil }
        let bytes = [UInt8](data)
        guard let gifData = CFDataCreate(nil, bytes, bytes.count) else { return nil }
        guard let image = CGImageSourceCreateWithData(gifData, nil) else { return nil }
        
        var time: Float = 0
        
        var framesArray: [AnyObject] = []
        var tempTimesArray: [NSNumber] = []
        let frameCount = CGImageSourceGetCount(image)
        
        for i in 0..<frameCount {
            var frameDuration = minFrameDuration
            let properties = CGImageSourceCopyPropertiesAtIndex(image, i, nil)
            guard let framePrpoerties = properties as? [String: AnyObject] else { return nil }
            guard let gifProperties = framePrpoerties[kCGImagePropertyGIFDictionary as String] as? [String: AnyObject] else { return nil }
            
            if let delayTimeUnclampedProp = gifProperties[kCGImagePropertyGIFUnclampedDelayTime as String] as? NSNumber {
                frameDuration = delayTimeUnclampedProp.floatValue
            } else {
                if let delayTimeProp = gifProperties[kCGImagePropertyGIFDelayTime as String] as? NSNumber {
                    frameDuration = delayTimeProp.floatValue
                }
            }
            
            if frameDuration < 0.011 {
                frameDuration = minFrameDuration
            }
            
            if let frame = CGImageSourceCreateImageAtIndex(image, i, nil) {
                tempTimesArray.append(NSNumber(value: frameDuration))
                framesArray.append(frame)
            }
            
            time += frameDuration
        }
        
        var timesArray: [NSNumber] = []
        var base: Float = 0
        for duration in tempTimesArray {
            base += duration.floatValue / time
            timesArray.append(NSNumber(value: base))
        }
        
        timesArray.append(NSNumber(value: 1.0))
        
        let animation = CAKeyframeAnimation(keyPath: "contents")
        animation.beginTime = CACurrentMediaTime()
        animation.duration = CFTimeInterval(time)
        animation.repeatCount = Float.greatestFiniteMagnitude
        animation.isRemovedOnCompletion = false
        animation.fillMode = .forwards
        animation.values = framesArray
        animation.keyTimes = timesArray
        animation.timingFunction = CAMediaTimingFunction(name: .linear)
        animation.calculationMode = .discrete
        return animation
    }
    
}
